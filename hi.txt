interface Node {
  id: string;
  position?: { x: number; y: number };
  children?: string[];
}

interface Edge {
  source: string;
  target: string;
}

const getTreeLayoutedNodes = (nodes: Node[], edges: Edge[]): Node[] => {
  const nodeWidth = 172;
  const nodeHeight = 36;
  const verticalSpacing = 50;
  const horizontalSpacing = 100;

  // Build a map of node ids to node objects for quick lookup
  const nodeMap: { [key: string]: Node } = {};
  nodes.forEach(node => nodeMap[node.id] = node);

  // Build a tree structure from the edges
  edges.forEach(edge => {
    const sourceNode = nodeMap[edge.source];
    if (!sourceNode.children) sourceNode.children = [];
    sourceNode.children.push(edge.target);
  });

  // Function to calculate positions
  const calculatePositions = (node: Node, depth: number, position: { x: number; y: number }) => {
    if (!node) return;
    
    node.position = { x: position.x, y: position.y };

    if (node.children && node.children.length > 0) {
      const totalWidth = node.children.length * (nodeWidth + horizontalSpacing);
      let offsetX = position.x - totalWidth / 2 + nodeWidth / 2;

      node.children.forEach(childId => {
        const childNode = nodeMap[childId];
        calculatePositions(childNode, depth + 1, {
          x: offsetX,
          y: position.y + nodeHeight + verticalSpacing
        });
        offsetX += nodeWidth + horizontalSpacing;
      });
    }
  };

  // Find the root node (assumed to be the one without incoming edges)
  const rootNodeId = nodes.find(node => !edges.some(edge => edge.target === node.id))?.id;
  if (rootNodeId) {
    const rootNode = nodeMap[rootNodeId];
    calculatePositions(rootNode, 0, { x: 0, y: 0 });
  }

  return nodes;
};
