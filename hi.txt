interface Node {
  id: string;
  position?: { x: number; y: number };
}

interface Edge {
  source: string;
  target: string;
}

type Direction = 'TB' | 'LR' | 'RL' | 'BT';

const getTreeLayoutedNodes = (nodes: Node[], edges: Edge[], direction: Direction = 'TB'): Node[] => {
  const nodeWidth = 172;
  const nodeHeight = 36;
  const verticalSpacing = 50;
  const horizontalSpacing = 100;

  // Build a map of node ids to node objects for quick lookup
  const nodeMap: { [key: string]: Node } = {};
  nodes.forEach(node => nodeMap[node.id] = node);

  // Build a parent-children map from the edges
  const parentMap: { [key: string]: string[] } = {};
  edges.forEach(edge => {
    if (!parentMap[edge.source]) {
      parentMap[edge.source] = [];
    }
    parentMap[edge.source].push(edge.target);
  });

  // Function to calculate the total width/height of a node's subtree
  const calculateSubtreeSize = (nodeId: string): number => {
    const children = parentMap[nodeId];
    if (!children || children.length === 0) {
      return direction === 'TB' || direction === 'BT' ? nodeWidth : nodeHeight;
    }
    return children.reduce((size, childId) => {
      return size + calculateSubtreeSize(childId) + (direction === 'TB' || direction === 'BT' ? horizontalSpacing : verticalSpacing);
    }, direction === 'TB' || direction === 'BT' ? -horizontalSpacing : -verticalSpacing); // Subtract spacing to avoid extra space after the last child
  };

  // Function to calculate positions
  const calculatePositions = (nodeId: string, depth: number, position: { x: number; y: number }) => {
    const node = nodeMap[nodeId];
    if (!node) return;
    
    node.position = { x: position.x, y: position.y };

    const children = parentMap[nodeId];
    if (children && children.length > 0) {
      const totalSize = children.reduce((size, childId) => {
        return size + calculateSubtreeSize(childId) + (direction === 'TB' || direction === 'BT' ? horizontalSpacing : verticalSpacing);
      }, direction === 'TB' || direction === 'BT' ? -horizontalSpacing : -verticalSpacing); // Subtract spacing to avoid extra space after the last child

      let offset = (direction === 'TB' || direction === 'BT' ? position.x : position.y) - totalSize / 2 + (direction === 'TB' || direction === 'BT' ? nodeWidth / 2 : nodeHeight / 2);

      children.forEach(childId => {
        const childSize = calculateSubtreeSize(childId);
        calculatePositions(childId, depth + 1, {
          x: direction === 'TB' || direction === 'BT' ? offset + childSize / 2 - nodeWidth / 2 : (direction === 'LR' ? position.x + nodeWidth + verticalSpacing : position.x - nodeWidth - verticalSpacing),
          y: direction === 'LR' || direction === 'RL' ? offset + childSize / 2 - nodeHeight / 2 : (direction === 'TB' ? position.y + nodeHeight + verticalSpacing : position.y - nodeHeight - verticalSpacing)
        });
        offset += childSize + (direction === 'TB' || direction === 'BT' ? horizontalSpacing : verticalSpacing);
      });
    }
  };

  // Find the root node (assumed to be the one without incoming edges)
  const rootNodeId = nodes.find(node => !edges.some(edge => edge.target === node.id))?.id;
  if (rootNodeId) {
    calculatePositions(rootNodeId, 0, { x: 0, y: 0 });
  }

  return nodes;
};

// Example usage
const nodes: Node[] = [
  { id: '1' },
  { id: '2' },
  { id: '3' },
  { id: '4' },
  { id: '5' },
  { id: '6' }
];

const edges: Edge[] = [
  { source: '1', target: '2' },
  { source: '1', target: '3' },
  { source: '2', target: '4' },
  { source: '2', target: '5' },
  { source: '3', target: '6' }
];

const layoutedNodes = getTreeLayoutedNodes(nodes, edges, 'LR'); // Change 'LR' to 'TB', 'BT', or 'RL' as needed
console.log(layoutedNodes);
