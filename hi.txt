const calculateNodePositions = (nodes) => {
  const nodeMap = {};
  const levels = {};

  // Initialize the root nodes (nodes without parentNode)
  nodes.forEach(node => {
    if (!node.data.parentNode) {
      node.position = { x: 0, y: 0 };
      nodeMap[node.id] = node;
      levels[node.id] = 0;  // Root nodes are at level 0
    }
  });

  // Recursive function to position children nodes
  const positionChildren = (parentId, depth, offsetX) => {
    const children = nodes.filter(node => node.data.parentNode === parentId);
    const spacingY = 100; // Vertical spacing between levels
    const spacingX = 200; // Horizontal spacing between siblings

    children.forEach((child, index) => {
      const parentNode = nodeMap[parentId];
      child.position = {
        x: parentNode.position.x + offsetX + (index * spacingX) - ((children.length - 1) * spacingX) / 2,
        y: parentNode.position.y + spacingY
      };
      nodeMap[child.id] = child;
      levels[child.id] = depth;

      // Recur for the child's children
      positionChildren(child.id, depth + 1, 0);
    });
  };

  // Position children of root nodes
  nodes.forEach(node => {
    if (!node.data.parentNode) {
      positionChildren(node.id, 1, 0);
    }
  });

  return nodes;
};
