interface Node {
  id: string;
  position?: { x: number; y: number };
}

interface Edge {
  source: string;
  target: string;
}

const getTreeLayoutedNodes = (nodes: Node[], edges: Edge[]): Node[] => {
  const nodeWidth = 172;
  const nodeHeight = 36;
  const verticalSpacing = 50;
  const horizontalSpacing = 100;

  // Build a map of node ids to node objects for quick lookup
  const nodeMap: { [key: string]: Node } = {};
  nodes.forEach(node => nodeMap[node.id] = node);

  // Build a parent-children map from the edges
  const parentMap: { [key: string]: string[] } = {};
  edges.forEach(edge => {
    if (!parentMap[edge.source]) {
      parentMap[edge.source] = [];
    }
    parentMap[edge.source].push(edge.target);
  });

  // Function to calculate the total width of a node's subtree
  const calculateSubtreeWidth = (nodeId: string): number => {
    const children = parentMap[nodeId];
    if (!children || children.length === 0) {
      return nodeWidth;
    }
    return children.reduce((width, childId) => {
      return width + calculateSubtreeWidth(childId) + horizontalSpacing;
    }, -horizontalSpacing); // Subtract horizontalSpacing to avoid extra space after the last child
  };

  // Function to calculate positions
  const calculatePositions = (nodeId: string, depth: number, position: { x: number; y: number }) => {
    const node = nodeMap[nodeId];
    if (!node) return;
    
    node.position = { x: position.x, y: position.y };

    const children = parentMap[nodeId];
    if (children && children.length > 0) {
      const totalWidth = children.reduce((width, childId) => {
        return width + calculateSubtreeWidth(childId) + horizontalSpacing;
      }, -horizontalSpacing); // Subtract horizontalSpacing to avoid extra space after the last child

      let offsetX = position.x - totalWidth / 2 + nodeWidth / 2;

      children.forEach(childId => {
        const childWidth = calculateSubtreeWidth(childId);
        calculatePositions(childId, depth + 1, {
          x: offsetX + childWidth / 2 - nodeWidth / 2,
          y: position.y + nodeHeight + verticalSpacing
        });
        offsetX += childWidth + horizontalSpacing;
      });
    }
  };

  // Find the root node (assumed to be the one without incoming edges)
  const rootNodeId = nodes.find(node => !edges.some(edge => edge.target === node.id))?.id;
  if (rootNodeId) {
    calculatePositions(rootNodeId, 0, { x: 0, y: 0 });
  }

  return nodes;
};

// Example usage
const nodes: Node[] = [
  { id: '1' },
  { id: '2' },
  { id: '3' },
  { id: '4' },
  { id: '5' },
  { id: '6' }
];

const edges: Edge[] = [
  { source: '1', target: '2' },
  { source: '1', target:
